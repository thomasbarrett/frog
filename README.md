# Frog 1.0.0-alpha

The Frog parsing library defines pattern types allowing the user to define
parsing expression grammars. This library is non-opinionated and imposes
very little structure on the user. The goal of Frog is to allow users to
get a project up and running as quickly as possible.

Parsing complex grammars is a tedious task which is only faced on occassion
by most programmers. Moreover, parsing tasks in need of high performance or
good error handling are often implemented as hand written recursive descent
parsers. A good example of this is the clang compiler. Rather than create a
feature rich library with documentation that nobody wants to read, Frog
attempts to create a parsing infrastructure that can be used right away.

Other popular C++ parsing libraries include boost::spirit and tao::pegtl.
Unlike boost::spirit, the Frog library is light weight and header only which
allows easy integration into projects of all sizes. The Frog library differs
from tao::pegtl since it uses functions rather than templates to express
a grammar. This declarative interface is intuitive and familiar,
which should allow easier adoption than a complex (albeit elegant) template
based library.

## Usage
You can get started with Frog by including the Frog header and defining
functions to express the grammar as shown below. This is a simple example
grammar for parsing expression with operator precedence. Note that since
PEG grammars cannot handle left recursion, epsilon rules are used to remove
left recursion.

```c++
namespace expression::grammar { 

    using namespace frog;

    Pattern Number() {
        return RegularExpression {"^[0-9]+"};
    }

    Pattern Expression();

    Pattern Factor() {
        return Sequence {'(', Expression, ')'}
             / Number;
    }

    Pattern Term_() {
        return Sequence {'*', Factor, Term_}
             / Sequence {'/', Factor, Term_}
             / Epsilon {};
    }

    Pattern Term() {
        return Sequence {Factor, Term_};
    }

    Pattern Expression_() {
        return Sequence {'+', Term, Expression_}
             / Sequence {'-', Term, Expression_}
             / Epsilon {};
    }

    Pattern Expression() {
        return Sequence{Term, Expression_};
    }
};
```

Frog can use your grammar to parse a string and generate a parse tree. 
This is as easy as calling in the `frog::Parse` function and passing in
the string to parse and the function representing the *start* symbol.

```c++ 
frog::Result result = frog::Parse(str, expression::grammar::Expression);
```

Currently, Frog does not have the ability to automatically walk the tree.
Thus, it is up to the user to walk the tree and perform semantics actions.
Generally, this code should mirror the grammer. The following example
walks a parse tree generated by the expression parser above and computes
the value.

```c++

namespace expression::action {

    int Number(frog::Result tree) {
        std::string lexeme { tree.str.substr(tree.start, tree.length) };
        return std::stoi(lexeme);
    }

    int Expression(frog::Result tree);

    int Factor(frog::Result tree) {
        switch (tree.index) {
            case 0: return Number(tree);
            case 1: return Expression(tree[1]);
            default: throw std::logic_error{"unreachable"};
        }
    }

    int Term_(int x, frog::Result tree) {
        switch (tree.index) {
            case 0: return Term_(x * Factor(tree[1]), tree[2]);
            case 1: return Term_(x / Factor(tree[1]), tree[2]);
            case 2: return x;
            default: throw std::logic_error{"unreachable"};
        }
    }

    int Term(frog::Result tree) {
        return Term_(Factor(tree[0]), tree[1]);
    }

    int Expression_(int x, frog::Result tree) {
        switch (tree.index) {
            case 0: return Expression_(x + Term(tree[1]), tree[2]);
            case 1: return Expression_(x - Term(tree[1]), tree[2]);
            case 2: return x;
            default: throw std::logic_error{"unreachable"};
        }
    }

    int Expression(frog::Result tree) {
        return Expression_(Term(tree[0]), tree[1]);
    }
}
```

## Todo
* Automatic tree traversal
* [Packrat style memoization](https://ohmlang.github.io/pubs/sle2017/incremental-packrat-parsing.pdf)

## Authors
* Thomas Barrett
